# 네트워크 요청 최적화 제안

## 현재 상황
- **345개의 네트워크 요청** 발생
- **LCP: 28.1초** (권장: 2.5초 이하)
- **FCP: 12초** (권장: 1.8초 이하)
- **TTI: 30.7초** (권장: 3.8초 이하)

## 주요 문제점 및 해결 방안

### 1. 이미지 최적화 (예상 요청 감소: ~100개)
- **문제**: 최적화되지 않은 대용량 이미지 다수 로딩
- **해결책**:
  ```
  - WebP 포맷으로 변환
  - 반응형 이미지 사용 (srcset)
  - Lazy Loading 적용
  - 이미지 CDN 활용
  ```

### 2. JavaScript 번들 최적화 (예상 요청 감소: ~50개)
- **문제**: 개별 JS 파일들이 병합되지 않음
- **해결책**:
  ```
  - 코드 스플리팅 적용
  - Tree Shaking으로 불필요한 코드 제거
  - 번들 크기 최소화 (Minification)
  - 중요하지 않은 스크립트는 defer/async 적용
  ```

### 3. CSS 최적화 (예상 요청 감소: ~30개)
- **문제**: 다수의 CSS 파일 개별 로딩
- **해결책**:
  ```
  - Critical CSS 인라인화
  - 나머지 CSS는 비동기 로딩
  - 사용하지 않는 CSS 제거
  - CSS 파일 병합 및 압축
  ```

### 4. 폰트 최적화 (예상 요청 감소: ~20개)
- **문제**: 웹폰트 과다 사용
- **해결책**:
  ```
  - font-display: swap 적용
  - 필요한 글자만 서브셋팅
  - WOFF2 포맷 사용
  - 폰트 preload 적용
  ```

### 5. 써드파티 스크립트 최적화 (예상 요청 감소: ~50개)
- **문제**: 광고, 분석 도구 등 외부 스크립트 과다
- **해결책**:
  ```
  - Google Tag Manager로 통합 관리
  - 필수적이지 않은 스크립트 제거
  - Lazy Loading 적용
  - Web Worker 활용 검토
  ```

### 6. HTTP/2 및 캐싱 전략
- **해결책**:
  ```
  - HTTP/2 멀티플렉싱 활용
  - 적절한 Cache-Control 헤더 설정
  - Service Worker 구현
  - CDN 활용
  ```

## 구체적 실행 계획

### Phase 1 (즉시 적용 가능)
1. 이미지 lazy loading 적용
2. Critical CSS 분리 및 인라인화
3. JavaScript defer/async 적용
4. 브라우저 캐싱 설정

### Phase 2 (1-2주 소요)
1. 이미지 포맷 변환 (WebP)
2. JavaScript 번들 최적화
3. 폰트 서브셋팅
4. CDN 도입

### Phase 3 (2-4주 소요)
1. Service Worker 구현
2. 코드 스플리팅 전면 적용
3. 써드파티 스크립트 최적화
4. HTTP/2 Server Push 활용

## 예상 결과
- **네트워크 요청: 345개 → 100개 이하**
- **LCP: 28.1초 → 3초 이하**
- **FCP: 12초 → 2초 이하**
- **TTI: 30.7초 → 5초 이하**
- **전체 성능 점수: 0점 → 70점 이상**

## 모니터링 및 검증
- Lighthouse CI 도입으로 지속적 성능 모니터링
- Real User Monitoring (RUM) 구현
- 주간 성능 리포트 자동화